<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/controllers/cart_items_controller.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/controllers/cart_items_controller.rb" />
              <option name="originalContent" value="class CartItemsController &lt; ApplicationController&#10;  before_action :require_user&#10;  before_action :set_cart_item, only: %i[ show edit update destroy ]&#10;  before_action :ensure_cart_item_belongs_to_current_user, only: %i[update destroy]&#10;&#10;&#10;  # GET /cart_items or /cart_items.json&#10;  def index&#10;    @cart_items = CartItem.all&#10;  end&#10;&#10;  # GET /cart_items/1 or /cart_items/1.json&#10;  def show&#10;  end&#10;&#10;  # GET /cart_items/new&#10;  def new&#10;    @cart_item = CartItem.new&#10;  end&#10;&#10;  # GET /cart_items/1/edit&#10;  def edit&#10;  end&#10;&#10;  # POST /cart_items or /cart_items.json&#10;  def create&#10;    customer = Customer.find_or_create_by(user: current_user)&#10;    @cart = Cart.find_or_create_by(customer: customer)&#10;&#10;    product = Product.find_by(id: params[:product_id])&#10;    return redirect_back fallback_location: products_path, alert: &quot;Product not found.&quot; unless product&#10;&#10;    quantity = extract_quantity(params) || 1&#10;    quantity = [ quantity.to_i, 1 ].max&#10;&#10;    if product.stock &lt; quantity&#10;      return redirect_to product_path(product), alert: &quot;Not enough stock available.&quot;&#10;    end&#10;&#10;    @cart_item = @cart.cart_items.find_or_initialize_by(product: product)&#10;    new_quantity = @cart_item.new_record? ? quantity : (@cart_item.quantity + quantity)&#10;&#10;    if new_quantity &gt; product.stock&#10;      return redirect_to product_path(product), alert: &quot;Cannot add that many items. Only #{product.stock} available.&quot;&#10;    end&#10;&#10;    @cart_item.quantity = new_quantity&#10;&#10;    if @cart_item.save&#10;      redirect_to cart_path, notice: &quot;Item added to cart successfully!&quot;&#10;    else&#10;      redirect_to product_path(product), alert: &quot;Failed to add item to cart.&quot;&#10;    end&#10;  end&#10;&#10;  # PATCH/PUT /cart_items/1 or /cart_items/1.json&#10;  def update&#10;    quantity = extract_quantity(params)&#10;    return redirect_to cart_path, alert: &quot;Invalid quantity.&quot; unless quantity.to_i &gt;= 1&#10;&#10;    if @cart_item.product.stock &lt; quantity.to_i&#10;      return redirect_to cart_path, alert: &quot;Not enough stock available.&quot;&#10;    end&#10;&#10;    if @cart_item.update(quantity: quantity)&#10;      redirect_to cart_path, notice: &quot;Cart updated successfully!&quot;&#10;    else&#10;      redirect_to cart_path, alert: &quot;Failed to update cart.&quot;&#10;    end&#10;  end&#10;&#10;  # DELETE /cart_items/1 or /cart_items/1.json&#10;  def destroy&#10;    @cart_item.destroy!&#10;&#10;    redirect_to cart_path, notice: &quot;Item removed from cart.&quot;&#10;  end&#10;&#10;  private&#10;    # Use callbacks to share common setup or constraints between actions.&#10;    def set_cart_item&#10;      @cart_item = CartItem.find_by(id: params[:id])&#10;      redirect_to cart_path, alert: &quot;Cart item not found.&quot; unless @cart_item&#10;    end&#10;&#10;    def ensure_cart_item_belongs_to_current_user&#10;      return if @cart_item&amp;.cart&amp;.customer&amp;.user_id == current_user.id&#10;&#10;      redirect_to root_path, alert: &quot;Not authorized.&quot;&#10;    end&#10;&#10;    # Only allow a list of trusted parameters through.&#10;    def cart_item_params&#10;      # Ensure :cart_item is present and only allow the listed attributes&#10;      params.require(:cart_item).permit(:cart_id, :product_id, :quantity)&#10;    end&#10;&#10;    def extract_quantity(params_obj)&#10;      if params_obj[:quantity].present?&#10;        params_obj[:quantity]&#10;      elsif params_obj[:cart_item].respond_to?(:[]) &amp;&amp; params_obj[:cart_item][:quantity].present?&#10;        params_obj[:cart_item][:quantity]&#10;      end&#10;    end&#10;end&#10;" />
              <option name="updatedContent" value="class CartItemsController &lt; ApplicationController&#10;  before_action :require_user&#10;  before_action :set_cart_item, only: %i[ show edit update destroy ]&#10;  before_action :ensure_cart_item_belongs_to_current_user, only: %i[update destroy]&#10;&#10;&#10;  # GET /cart_items or /cart_items.json&#10;  def index&#10;    @cart_items = CartItem.all&#10;  end&#10;&#10;  # GET /cart_items/1 or /cart_items/1.json&#10;  def show&#10;  end&#10;&#10;  # GET /cart_items/new&#10;  def new&#10;    @cart_item = CartItem.new&#10;  end&#10;&#10;  # GET /cart_items/1/edit&#10;  def edit&#10;  end&#10;&#10;  # POST /cart_items or /cart_items.json&#10;  def create&#10;    customer = Customer.find_or_create_by(user: current_user)&#10;    @cart = Cart.find_or_create_by(customer: customer)&#10;&#10;    product = Product.find_by(id: params[:product_id])&#10;    return redirect_back fallback_location: products_path, alert: &quot;Product not found.&quot; unless product&#10;&#10;    quantity = extract_quantity(params) || 1&#10;    quantity = [ quantity.to_i, 1 ].max&#10;&#10;    if product.stock &lt; quantity&#10;      return redirect_to product_path(product), alert: &quot;Not enough stock available.&quot;&#10;    end&#10;&#10;    @cart_item = @cart.cart_items.find_or_initialize_by(product: product)&#10;    new_quantity = @cart_item.new_record? ? quantity : (@cart_item.quantity + quantity)&#10;&#10;    if new_quantity &gt; product.stock&#10;      return redirect_to product_path(product), alert: &quot;Cannot add that many items. Only #{product.stock} available.&quot;&#10;    end&#10;&#10;    @cart_item.quantity = new_quantity&#10;&#10;    if @cart_item.save&#10;      redirect_to cart_path, notice: &quot;Item added to cart successfully!&quot;&#10;    else&#10;      redirect_to product_path(product), alert: &quot;Failed to add item to cart.&quot;&#10;    end&#10;  end&#10;&#10;  # PATCH/PUT /cart_items/1 or /cart_items/1.json&#10;  def update&#10;    quantity = extract_quantity(params)&#10;    return redirect_to cart_path, alert: &quot;Invalid quantity.&quot; unless quantity.to_i &gt;= 1&#10;&#10;    if @cart_item.product.stock &lt; quantity.to_i&#10;      return redirect_to cart_path, alert: &quot;Not enough stock available.&quot;&#10;    end&#10;&#10;    if @cart_item.update(quantity: quantity)&#10;      redirect_to cart_path, notice: &quot;Cart updated successfully!&quot;&#10;    else&#10;      redirect_to cart_path, alert: &quot;Failed to update cart.&quot;&#10;    end&#10;  end&#10;&#10;  # DELETE /cart_items/1 or /cart_items/1.json&#10;  def destroy&#10;    @cart_item.destroy!&#10;&#10;    redirect_to cart_path, notice: &quot;Item removed from cart.&quot;&#10;  end&#10;&#10;  private&#10;    # Use callbacks to share common setup or constraints between actions.&#10;    def set_cart_item&#10;      @cart_item = CartItem.find_by(id: params[:id])&#10;      redirect_to cart_path, alert: &quot;Cart item not found.&quot; unless @cart_item&#10;    end&#10;&#10;    def ensure_cart_item_belongs_to_current_user&#10;      return if @cart_item&amp;.cart&amp;.customer&amp;.user_id == current_user.id&#10;&#10;      redirect_to root_path, alert: &quot;Not authorized.&quot;&#10;    end&#10;&#10;    # Only allow a list of trusted parameters through.&#10;    def cart_item_params&#10;      # Ensure :cart_item is present and only allow the listed attributes&#10;      params.require(:cart_item).permit(:cart_id, :product_id, :quantity)&#10;    end&#10;&#10;    def extract_quantity(params_obj)&#10;      if params_obj[:quantity].present?&#10;        params_obj[:quantity]&#10;      elsif params_obj[:cart_item].respond_to?(:[]) &amp;&amp; params_obj[:cart_item][:quantity].present?&#10;        params_obj[:cart_item][:quantity]&#10;      end&#10;    end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>